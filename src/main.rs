use std::{
    env,
    fs::{self, File},
    io::Write,
    path::Path,
    process::Command,
};

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() == 0 {
        println!("USAGE: gmod project-name");
        return;
    }

    let project_name = args.get(1).unwrap();
    println!("creating project {}", project_name);

    if Path::new(project_name).exists() {
        println!("the directory `{}' already exist", project_name);
        return;
    }
    //create a directory with the projct name
    //
    let res = fs::create_dir(project_name);
    if res.is_err() {
        println!(" failed to create a directory {:?}", res.err());
        return;
    }
    println!("setting up files...");
    //create a main.go file
    let main = Path::new(project_name).join("main.go");
    let mut main = match File::create(main) {
        Ok(f) => f,
        Err(e) => {
            println!("failed to create {:?}", e);
            return;
        }
    };

    let main_content = r#"//generated by gmod
package main

import "fmt" 
        
func main(){
    fmt.Println("hello sire!")
}
"#;

    match main.write_all(main_content.as_bytes()) {
        Ok(_) => {}
        Err(e) => {
            println!("failed write main.go: {}", e.kind());
        }
    }

    //flush it
    main.flush().unwrap();

    //TODO: create a Makefile
    //setup go mob by calling go mod init
    let mut module = String::from("github.com/NishanthSpShetty/");
    module.push_str(&project_name);
    Command::new("go")
        .args(["mod", "init"])
        .arg(module)
        .current_dir(project_name)
        .spawn()
        .expect("failed to initialize go mod");
    println!("done");
}
